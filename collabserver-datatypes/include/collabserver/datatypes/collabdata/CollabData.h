#pragma once

#include <cassert>
#include <string>
#include <vector>

#include "CollabDataOperation.h"
#include "CollabDataOperationObserver.h"

namespace collabserver {

/**
 * \brief
 * Abstract class for data built on top of CRDT primitives.
 *
 * CollabData is meant to be used in distributed environments.
 * It is a 'end-user' data that internally uses primitive CRDTs to deal
 * with concurrent changes without any synchronization or lock.
 *
 * Don't confuse with thread safe. CollabData is not thread safe.
 * Several users may work at the same time on the same CollabData without any
 * conflicts, lock and synchronization. However, the local replicate applies
 * modifications in one thread (For instance, a server that receives
 * modifications from several users but applies them on one thread).
 * CollabData deals with the fact that operations themselves may be concurrent.
 * (ex: Bob deletes a component that Alice has modified at the same time).
 *
 *
 * \par Methods rules
 * All methods on this data are associative, commutative, and idempotent.
 *  - Associative
 *      (a + b) + c = a + (b + c)
 *  - Commutative
 *      (a + b) = (b + a)
 *  - Idempotent
 *      (a + b) = (a + b) + b
 *
 * \par CollabDataOperation
 * Operation describes an atomic change on the data. Your CollabData has its
 * own set of CollabDataOperation that you defined and are specific for this data.
 * Each operation is a class that implements CollabDataOperation interface and describes
 * a specific modification. (ex: add element in map). You may defines
 * operation as nested classes of your data.
 *
 * \par CollabDataOperationObserver
 * Any modification on the data generates an CollabDataOperation that describes this
 * atomic change and notifies all its observers. These CollabDataOperationObservers
 * then receive the operation and may process is as they wish. For instance,
 * update a GUI or update a log of operations.
 * Note that CollabDataOperationObserver shouldn't be used in order to send the operation
 * to other replicates, use the broadcaster instead.
 * \par
 * IMPORTANT NOTE: CollabDataOperationObserver are notified only of operations that
 * are valid from the end-user point of view.
 * Methods may have semantic dependencies, for instance, to modify an element,
 * it must be created first. (Causality preservation). To remove
 * any synchronization mechanism, all methods are technically valid. Internally,
 * CRDTs are totally commutative by design. (for instance, element may be added
 * temporary in order to apply the modification)
 * CollabDataOperationObserver creates the borderland between internal CRDT (Where
 * everything is valid) and the end-user semantic which requires causality
 * preservation.
 *
 * \par Broadcaster
 * This is a special kind CollabDataOperationObserver. They technically both implement
 * CollabDataOperationObserver and receive notification of operations.
 * However, Broadcaster is notified only for CollabDataOperations generated by the local
 * user in order to send them to other replicates.
 * More over, broadcaster sent all operation regardless causality preservation.
 * This is required since all replicates must apply the exact same set of
 * operations locally.
 * Using normal CollabDataOperationObserver for this task will result in a possible loop
 * since external modification will be sent back to its creator.
 * How broadcaster actually deals with operation broadcasting is unknown here.
 * This is an implementation detail that CollabData is not aware of.
 * You may use BSD sockets, any network communication or magic birds, CollabData
 * only knows about a broadcaster that listen to its changes.
 *
 * \par How to implement your custom CollabData
 *  - Create your data that implements CollabData
 *  - Build your internal data on top of CRDTs primitives (ex: CmRDT::LWWMap)
 *  - Create a set of operations for your data
 *
 * \par How to use you custom CollabData
 *  - Create class that implements CollabDataOperationObserver
 *  - Deal with each possible CollabDataOperation (Update UI, Insert in Database...)
 *  - Register your CollabDataOperationObservers in your CollabData
 *  - Create a broadcaster that implements CollabDataOperationObserver
 *  - Register broadcaster in your CollabData
 *
 *
 * \see CollabDataOperation
 * \see CollabDataOperationObserver
 */
class CollabData {
   private:
    std::vector<CollabDataOperationObserver*> _operationObservers;
    CollabDataOperationObserver* _broadcaster = nullptr;

    // -------------------------------------------------------------------------
    // Initialization
    // -------------------------------------------------------------------------

   protected:
    CollabData() = default;
    CollabData(const CollabData& other) = default;
    CollabData& operator=(const CollabData& other) = default;

   public:
    virtual ~CollabData() = default;  // For polymorphism

    // -------------------------------------------------------------------------
    // CollabDataOperation Methods
    // -------------------------------------------------------------------------

   public:
    /**
     * Apply an operation received from external component.
     * CollabDataOperation is received in its serialized form.
     * Do nothing if unable to unserialize and return false.
     * This doesn't notify the broadcaster but only the CollabDataOperation Observers.
     *
     * This may for instance be used by a network component to apply an
     * operation just received. CollabDataOperation is in its serialized form since
     * other components doesn't know anything about the concrete operations.
     * (Only concrete CollabData implementation knowns)
     *
     * \param id CollabDataOperation's ID.
     * \param buffer Serialized version of the operation.
     * \return True if operation is valid, otherwise, return false.
     */
    virtual bool applyExternOperation(unsigned int id, const std::string& buffer) = 0;

    // -------------------------------------------------------------------------
    // CollabDataOperationObservers Methods
    // -------------------------------------------------------------------------

   public:
    /**
     * Send a local operation to all CollabDataOperationObservers.
     *
     * Method that modifies data creates an operations that describes this
     * modification. Several components may request to know about these
     * operations, for instance a UI display.
     *
     * \param Reference to the operation.
     */
    void notifyOperationObservers(const CollabDataOperation& op) const {
        assert(op.getType() != 0);  // If 0, you probably forgot to set type

        for (CollabDataOperationObserver* superman : _operationObservers) {
            assert(superman != nullptr);
            superman->onOperation(op);
        }
    }

    /**
     * Registers a CollabDataOperationObserver in this data.
     * Does nothing if this observer is already registered (Returns false).
     * Does nothing if nullptr is given (Returns false).
     *
     * \param observer The observer to add.
     * \return True if added, otherwise, return false.
     */
    bool addOperationObserver(CollabDataOperationObserver& observer) {
        for (CollabDataOperationObserver* const obs : _operationObservers) {
            if (obs == &observer) {
                return false;
            }
        }
        _operationObservers.push_back(&observer);
        return true;
    }

    /**
     * Removes all current operation observers.
     */
    void clearOperationObservers() { _operationObservers.clear(); }

    /**
     * Returns the number of operation observer registered in this data.
     *
     * \return Number of registered CollabDataOperationObserver.
     */
    std::vector<CollabDataOperationObserver>::size_type sizeOperationObserver() const {
        return _operationObservers.size();
    }

    // -------------------------------------------------------------------------
    // Broadcaster Methods
    // -------------------------------------------------------------------------

   public:
    /**
     * Notify the broadcaster that an operation took place.
     * Do nothing if no broadcaster set.
     *
     * \param Reference to the operation to broadcast.
     */
    void notifyOperationBroadcaster(const CollabDataOperation& op) const {
        if (_broadcaster != nullptr) {
            _broadcaster->onOperation(op);
        }
    }

    /**
     * Associate a broadcaster for this data.
     * If data already has a broadcaster, it is updated with this one.
     */
    void setOperationBroadcaster(CollabDataOperationObserver& observer) { _broadcaster = &observer; }

    /**
     * Removes broadcaster for this data.
     */
    void removeOperationBroadcaster() { _broadcaster = nullptr; }

    /**
     * Check whether a broadcaster is set.
     * Data without a broadcaster means its a local data only.
     *
     * \return True if broadcaster set, otherwise, return false.
     */
    bool hasBroadcaster() const { return _broadcaster != nullptr; }
};

}  // namespace collabserver
